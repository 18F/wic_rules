import json
from collections import defaultdict

from django.db import models, connection


class Ruleset(models.Model):
    program = models.TextField(null=False, blank=False)
    entity = models.TextField(null=False, blank=False)
    record_spec = models.TextField(null=False, blank=False)

    def rule_results(self, applicants):
        """Results from applying each rule in ruleset to each applicant.

        :param applicants: Iterable of applicants as provided in request
        :return: Results from applying each rule in ruleset to each applicant:

            [
            {1: [{'rule': <Rule: Rule object (1)>, 'result': False},
                 {'rule': <Rule: Rule object (2)>, 'result': True}]},
            ]

            where 'result' is whether the applicant passes rule's code.
        """

        results = defaultdict(list)
        for rule in self.rule_set.order_by('order').all():
            sql = """
                with applicants as (
                  select * from json_to_recordset('{applicants}')
                  as x({self.record_spec})
              )
              select id,
                     {rule.code} AS result
              from   applicants
            """.format(
                self=self, rule=rule, applicants=json.dumps(applicants))
            with connection.cursor() as cursor:
                cursor.execute(sql)
                for row in cursor.fetchall():
                    (id, result) = row
                    results[id].append({'rule': rule, 'result': result})
        return results

    def report_from_rule_results(self, applicants, results):
        """Interpretation of results generated by `self.urle_results`

        :param applicants: Iterable of applicant data
        :param results: Results from `self.rule_results`
        :return: List of dicts describing each applicant's results.  Example:

             [{'id': 1, 'accepted': False, 'reasons':
                [{'rule_id': 1,
                  'description': 'Income exceeds 185% of poverty level.'}]}]

        """

        for applicant in applicants:
            yield self.applicant_report_from_rule_results(
                applicant=applicant, results=results)

    def applicant_report_from_rule_results(self, applicant, results):

        id = applicant['id']
        report = {'id': id, 'accepted': None, 'reasons': []}
        for rule_result in results[id]:
            (rule, result) = (rule_result['rule'], rule_result['result'])
            if rule.qualifies_with(result):
                report['reasons'] = [
                    {
                        'rule_id': rule.id,
                        'description': rule.explanation
                    },
                ]
                return report
            elif rule.disqualifies_with(result):
                report['accepted'] = False
                report['reasons'].append({
                    'rule_id': rule.id,
                    'description': rule.explanation
                })
                if rule.hard_disqualifies_with(result):
                    return report
        return report  # No disqualifying conditions found

    # def apply_to(self, applicants):
    #     reports = self.apply_sql(applicants)
    #     for applicant in applicants:
    #         try:
    #             id = applicant['id']
    #             result = {
    #                 'id': id,
    #                 'accepted': False,
    #                 'reasons': [{
    #                     'rule_id': 1,
    #                     'description': 'Just because'
    #                 }]
    #             }
    #             yield result
    #         except KeyError:
    #             reason = 'Applicant lacks "id" field: {}'.format(applicant)
    #             raise exceptions.ValidationError(reason)

    # TODO: keep old rulesets when rules change?


class Rule(models.Model):
    order = models.IntegerField(null=False, blank=False)
    name = models.TextField(null=False, blank=False)
    code = models.TextField(null=False, blank=False)
    qualifies = models.TextField(
        null=True)  # None = required, but does not qualify or disqualify
    explanation = models.TextField(null=False, blank=False)
    ruleset = models.ForeignKey(Ruleset, on_delete=models.CASCADE)

    # TODO: Parameterization, for similar rules with simple differences

    def qualifies_with(self, result):
        "Given boolean `result`, is this applicant automatically accepted?"

        return result and self.qualifies

    def hard_disqualifies_with(self, result):
        "Given boolean `result`, is this applicant automatically rejected?"

        return result and (self.qualifies is False)

    def disqualifies_with(self, result):
        "Given boolean `result`, is this applicant rejected?"

        if self.qualifies:
            return False

        if self.hard_disqualifies_with(result):
            return True

        return not result
