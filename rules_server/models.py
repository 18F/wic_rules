import json
from collections import defaultdict
from string import Template

from django.db import connection, models


class Ruleset(models.Model):
    program = models.TextField(null=False, blank=False)
    entity = models.TextField(null=False, blank=False)
    record_spec = models.TextField(null=False, blank=False)

    @property
    def definitions_sql(self):
        return "".join(', ' + str(d) for d in self.definition_set.all())

    @property
    def json_fields(self):
        """All the field names in `self.record_spec"""

        return [s.split()[0] for s in self.record_spec.split(',')]

    def rule_results(self, applicants):
        """Results from applying each rule in ruleset to each applicant.

        :param applicants: Iterable of applicants as provided in request
        :return: Results from applying each rule in ruleset to each applicant:

            [
            {1: [{'rule': <Rule: Rule object (1)>, 'result': False},
                 {'rule': <Rule: Rule object (2)>, 'result': True}]},
            ]

            where 'result' is whether the applicant passes rule's code.
        """

        results = defaultdict(list)

        for rule in self.rule_set.order_by('order').all():
            sql = rule.sql(data=applicants)
            with connection.cursor() as cursor:
                cursor.execute(sql)
                for row in cursor.fetchall():
                    (id, result, explanation) = row
                    results[id].append({
                        'rule': rule,
                        'result': result,
                        'explanation': explanation
                    })
        return results

    def report_from_rule_results(self, applicants, results):
        """Interpretation of results generated by `self.urle_results``

        :param applicants: Iterable of applicant data
        :param results: Results from `self.rule_results`
        :return: List of dicts describing each applicant's results.  Example:

             [{'id': 1, 'accepted': False, 'reasons':
                [{'rule_id': 1,
                  'description': 'Income exceeds 185% of poverty level.'}]}]

        """

        for applicant in applicants:
            yield self.applicant_report_from_rule_results(
                applicant=applicant, results=results)

    def applicant_report_from_rule_results(self, applicant, results):

        id = applicant['id']
        report = {'id': id, 'accepted': True, 'reasons': []}
        for rule_result in results[id]:
            (rule, result,
             explanation) = (rule_result['rule'], rule_result['result'],
                             rule_result['explanation'])
            if rule.qualifies_with(result):
                report['reasons'] = [
                    {
                        'rule_id': rule.id,
                        'description': explanation
                    },
                ]
                return report
            elif rule.disqualifies_with(result):
                report['accepted'] = False
                report['reasons'].append({
                    'rule_id': rule.id,
                    'description': explanation,
                })
                if rule.hard_disqualifies_with(result):
                    return report
        return report  # No disqualifying conditions found


class Definition(models.Model):
    term = models.TextField(null=False, blank=False)
    code = models.TextField(null=False, blank=False)
    explanation = models.TextField(null=False, blank=False)
    ruleset = models.ForeignKey(Ruleset, on_delete=models.CASCADE)

    def __str__(self):
        return ', ({}) AS {}'.format(self.code, self.term)


class Rule(models.Model):
    order = models.IntegerField(null=False, blank=False)
    name = models.TextField(null=False, blank=False)
    code = models.TextField(null=False, blank=False)
    qualifies = models.TextField(
        null=True)  # None = required, but does not qualify or disqualify
    explanation = models.TextField(null=False, blank=False)
    ruleset = models.ForeignKey(Ruleset, on_delete=models.CASCADE)
    array_field = models.TextField(null=True)
    aggregate_definitions = models.TextField(null=True)
    aggregate_filters = models.TextField(null=True)

    # TODO: Parameterization, for similar rules with simple differences

    def terms(self):

        if self.json_field_used:
            return ', jsonb_array_elements({field}) AS {field}_rows'.format(
                field=self.json_field_used)
        else:
            return ''

    def qualifies_with(self, result):
        "Given boolean `result`, is this applicant automatically accepted?"

        return result and self.qualifies

    def hard_disqualifies_with(self, result):
        "Given boolean `result`, is this applicant automatically rejected?"

        return result and (self.qualifies is False)

    def disqualifies_with(self, result):
        "Given boolean `result`, is this applicant rejected?"

        if self.qualifies:
            return False

        if self.hard_disqualifies_with(result):
            return True

        return not result

    @property
    def array_term(self):
        if self.array_field:
            return ', jsonb_array_elements({field}) AS {field}_elements'.format(
                field=self.array_field)
        else:
            return ''

    def core_source_sql(self, data):
        template = Template("""
            with src as (
              select * $definitions $array_term
              from json_to_recordset('$data')
              as x($record_spec)
              )
        """)
        data = json.dumps(data)  # escape up $, ', SQL injection
        result = template.substitute(
            definitions=self.ruleset.definitions_sql,
            data=data,
            array_term=self.array_term,
            record_spec=self.ruleset.record_spec)
        return result

    @property
    def group_by(self):
        """SQL list of field names to group by when aggregating"""

        result = self.ruleset.json_fields
        result.remove(self.array_field)
        return ", ".join(result)

    def source_sql(self, data):

        core = self.core_source_sql(data)
        if not self.array_field:
            return core
        core = core.replace('$', '$$')

        template = Template("""
          with src as (
            $core
          select $group_by 
                 $aggregate_definitions
          from src
          $aggregate_filters
          group by $group_by
          )
        """)
        result = template.substitute(
            core=core,
            group_by=self.group_by,
            aggregate_definitions=self.aggregate_definitions or '',
            aggregate_filters=self.aggregate_filters or '')
        return result

    def sql(self, data):
        result = self.source_sql(data) + """
        select id, """ + self.code + """ AS result,  
                   """ + self.explanation + """ AS explanation 
        from src"""

        return result
